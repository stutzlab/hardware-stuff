{{+------------------------------------------+  ¦ I2C driver in SPIN                       ¦      This routine requires the use of pull-up resistors on the SDA and SCL lines   ¦ Author: Chris Gadd                       ¦      Runs entirely in SPIN  ¦ Copyright (c) 2013 Chris Gadd            ¦      Approximately 22Kbps  ¦ See end of file for terms of use.        ¦      Supports clock-stretching by slave devices  +------------------------------------------+  To use:    I2C.start(28,29)                                Start the I2C driver using p28 for clock and p29 for data    \I2C.write(I2C#EEPROM,$0123,$45)                Write $45 to EEPROM address $0123     \I2C.write_page(I2C#EEPROM,$0123,@Array,500)    Write 500 bytes from Array to EEPROM starting at address $0123    \I2C.command(I2C#Alt,$48)                       Issue command to 'convert D1' to a MS5607 altimeter (Altimeter is the only device, so far discovered, that needs this routine)    \I2C.read(I2C#EEPROM,$0123)                     Read a byte from EEPROM address $0123    \I2C.read_next(I2C#EEPROM)                      Read a byte from EEPROM address $0124 (the next address following a 'read')    \I2C.read_page(I2C#EEPROM,$0123,@Array,500)     Read 500 bytes from an EEPROM starting at address $0123 and store each byte in Array    ?    +-Note the abort trap        This routine performs ACK polling to determine when a device is ready.    Routine will abort a transmission if no ACK is received within 10ms of polling - prevents I2C routine from stalling if a device becomes disconnected     The abort trap "\" must be used by a calling method    No other ACK testing is performed    This routine automatically uses two bytes when addressing an EEPROM.  EEPROM is the only device, so far discovered, that uses two-byte addresses.                 '----------------------------------------------------------------------------------------------------------------------        +-Start---Bit 1---Bit 0---Ack(r)--Start---Read----Ack(t)--Read-----NAK----Stop--+             SCL ?????????????????????????????????????????????????????????????????????????????????             SDA ?????????????????????????-------?????????-------?????????-------?????????????????           }}                                                                                                                                                CON'Device codes  EEPROM = %0101_0000           ' Device code for 24LC256 EEPROM with all chip select pins tied to ground  RTC    = %0110_1000           ' Device code for DS1307 real time clock  Acc    = %0001_1101           ' Device code for MMA7455L 3-axis accelerometer  Gyro   = %0110_1001           ' Device code for L3G4200D gyroscope (SDO to Vdd)  Alt    = %0111_0110           ' Device code for MS5607 altimeter (CS floating)  IO     = %0010_0001           ' Device code for CY8C9520A IO port expander (Strong pull-up (330O or less on A0))                                '  Pull-up required when using the CY8C9520A EEPROM device, addressed at 101_000a                                    VAR  byte  scl,sda       OBJ
  vp   : "Terminal"          'transfers data to/from PC  
PUB start(scl_pin,sda_pin)  scl := scl_pin  sda := sda_pin  PUB write(device,address,data)                                                  ' Write a single byte  send_start(device,address)  I2C_write(data)  I2C_stop  result := true  PUB write_page(device,address,data_address,bytes)                               ' Write many bytes  send_start(device,address)  repeat bytes    I2C_write(byte[data_address])    data_address++  I2C_stop  result := truePUB command(device,comm)                                                        ' Write the device and address, no data.  Used in the altimeter  send_start(device,comm)  I2C_stop  result := true                                                            PUB read(device,address)                                                        ' Read a single byte  send_start(device,address)  I2C_start  I2C_write(device << 1 | 1)    result := I2C_read  I2C_nak  I2C_stop     PUB read_next(device)                                                           ' Read from next address  I2C_start  I2C_write(device << 1 | 1)    result := I2C_read  I2C_nak  I2C_stopPUB read_page(device,address,data_address,bytes)                                 ' Read many bytes  send_start(device,address)  I2C_start  I2C_write(device << 1 | 1)  repeat bytes    byte[data_address] := I2C_read    if bytes-- > 1      I2C_ack    else      I2C_nak    data_address++  I2C_stop  dira[sda]~  result := truePRI send_start (device, address) | NAK, t  nak := 1  t := cnt   repeat while nak                                                                  if cnt - t > clkfreq / 100      abort false    I2C_start    nak := I2C_write(device << 1)  if device & %1111_1000 == EEPROM    I2C_write(address >> 8)  I2C_write(address)    PRI I2C_start                                                                   ' SCL ????????  dira[scl]~                                                                    ' SDA ????????  waitpeq(SCL,SCL,0)  dira[sda]~  dira[sda]~~  dira[scl]~~PRI I2C_write(data)                                                             '   (Write)      (Read ACK or NAK)  repeat 8                                                                      '     ?            ?                   dira[sda] := !(data >> 7)                                                   ' SCL ???????? ????????                dira[scl]~                                                                  ' SDA ???????? ?-------                waitpeq(SCL,SCL,0)    dira[scl]~~    data <<= 1  dira[sda]~  dira[scl]~  waitpeq(SCL,SCL,0)  result := ina[sda]  dira[scl]~~PRI I2C_read                                                                    '      (Read)    dira[sda]~                                                                    '         ?      repeat 8                                                                      ' SCL ????????     dira[scl]~                                                                  ' SDA ?-------    waitpeq(SCL,SCL,0)    result := result << 1 | ina[sda]    dira[scl]~~PRI I2C_ack                                                                     ' SCL ????????            dira[sda]~~                                                                   ' SDA ????????  dira[scl]~  waitpeq(SCL,SCL,0)  dira[scl]~~PRI I2C_nak                                                                     ' SCL ????????  dira[sda]~                                                                    ' SDA ????????  dira[scl]~  waitpeq(SCL,SCL,0)  dira[scl]~~PRI I2C_stop                                                                    ' SCL ????????  dira[sda]~~                                                                   ' SDA ????????  dira[scl]~  waitpeq(SCL,SCL,0)  dira[sda]~                                                                                DAT{{+------------------------------------------------------------------------------------------------------------------------------+¦                                                   TERMS OF USE: MIT License                                                  ¦                                                            +------------------------------------------------------------------------------------------------------------------------------¦¦Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    ¦ ¦files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    ¦¦modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software¦¦is furnished to do so, subject to the following conditions:                                                                   ¦¦                                                                                                                              ¦¦The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.¦¦                                                                                                                              ¦¦THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          ¦¦WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         ¦¦COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   ¦¦ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         ¦+------------------------------------------------------------------------------------------------------------------------------+}}